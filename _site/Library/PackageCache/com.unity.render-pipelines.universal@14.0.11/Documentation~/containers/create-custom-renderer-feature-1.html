<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Example of a complete Scriptable Renderer Feature | mmo-rpg-unity </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Example of a complete Scriptable Renderer Feature | mmo-rpg-unity ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/0xVector/mmo-rpg-unity/blob/master/Library/PackageCache/com.unity.render-pipelines.universal@14.0.11/Documentation~/containers/create-custom-renderer-feature-1.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../logo.svg" alt="mmo-rpg-unity">
            mmo-rpg-unity
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="example-of-a-complete-scriptable-renderer-feature">Example of a complete Scriptable Renderer Feature</h1>

<p>This section describes how to create a complete <a href="../renderer-features/scriptable-renderer-features/intro-to-scriptable-renderer-features.html">Scriptable Renderer Feature</a> for a URP Renderer.</p>
<p>This walkthrough contains the following sections:</p>
<ul>
<li><a href="#example-implementation-overview">Overview of this example implementation</a></li>
<li><a href="#example-scene">Create example Scene and GameObjects</a></li>
<li><a href="#scriptable-renderer-feature">Create a scriptable Renderer Feature and add it to the Universal Renderer</a>
<ul>
<li><a href="#add-renderer-feature-to-asset">Add the Renderer Feature to the the Universal Renderer asset</a></li>
</ul>
</li>
<li><a href="#scriptable-render-pass">Create the scriptable Render Pass</a></li>
<li><a href="#implement-the-settings-for-the-custom-render-pass">Implement the settings for the custom render pass</a></li>
<li><a href="#enqueue-the-render-pass-in-the-custom-renderer-feature">Enqueue the render pass in the custom renderer feature</a></li>
<li><a href="#volume-component">Implement the volume component</a></li>
<li><a href="#complete-code-for-the-scripts-in-this-example">Complete code for the scripts in this example</a>
<ul>
<li><a href="#code-renderer-feature">Custom Renderer Feature code</a></li>
<li><a href="#code-render-pass">Custom render pass code</a></li>
<li><a href="#code-volume-component">Volume Component code</a></li>
</ul>
</li>
<li><a href="#example-shader">The custom shader for the blur effect</a></li>
</ul>
<h2 id="example-implementation-overview">Overview of this example implementation</h2>
<p>The example workflow on this page implements a custom Renderer Feature that uses <a href="../renderer-features/intro-to-scriptable-render-passes.html">custom Render Passes</a> to add a blur effect to the camera output.</p>
<p>The implementation consists of the following parts:</p>
<ul>
<li><p>A <code>ScriptableRendererFeature</code> instance that enqueues a <code>ScriptableRenderPass</code> instance every frame.</p>
</li>
<li><p>A <code>ScriptableRenderPass</code> instance that performs the following steps:</p>
<ul>
<li><p>Creates a temporary render texture using the <code>RenderTextureDescriptor</code> API.</p>
</li>
<li><p>Applies two passes of the <a href="#example-shader">custom shader</a> to the camera output using the <code>RTHandle</code> and the <code>Blit</code> API.</p>
</li>
</ul>
</li>
</ul>
<h2 id="example-scene">Create example Scene and GameObjects</h2>
<p>To set your project up for this example workflow:</p>
<ol>
<li><p>Create a new Scene.</p>
</li>
<li><p>Create two GameObjects: a Cube GameObject called <code>Cube</code>, and a Sphere GameObject called <code>Sphere</code>.</p>
</li>
<li><p>Create two Materials with a shader that lets you specify the base color (for example, the <code>Universal Render Pipeline/Lit</code> shader). Call the Materials <code>Blue</code> and <code>Red</code>, and set the base colors of the Materials to blue and red respectively.</p>
</li>
<li><p>Assign the <code>Red</code> Material to the cube and the <code>Blue</code> Material to the sphere.</p>
</li>
<li><p>Position the camera so that it has the cube and the sphere in its view.</p>
</li>
</ol>
<p>The sample scene should look like the following image:</p>
<p><img src="../Images/customizing-urp/custom-renderer-feature/sample-scene.png" alt="Sample scene"></p>
<h2 id="scriptable-renderer-feature">Create a scriptable Renderer Feature and add it to the Universal Renderer</h2>
<ol>
<li><p>Create a new C# script and name it <code>BlurRendererFeature.cs</code>.</p>
</li>
<li><p>In the script, remove the code that Unity inserted in the <code>BlurRendererFeature</code> class.</p>
</li>
<li><p>Add the following <code>using</code> directive:</p>
<pre><code class="lang-C#">using UnityEngine.Rendering.Universal;
</code></pre>
</li>
<li><p>Create the <code>BlurRendererFeature</code> class that inherits from the <strong>ScriptableRendererFeature</strong> class.</p>
<pre><code class="lang-C#">public class BlurRendererFeature : ScriptableRendererFeature    
</code></pre>
</li>
<li><p>In the <code>BlurRendererFeature</code> class, implement the following methods:</p>
<ul>
<li><p><code>Create</code>: Unity calls this method on the following events:</p>
<ul>
<li><p>When the Renderer Feature loads the first time.</p>
</li>
<li><p>When you enable or disable the Renderer Feature.</p>
</li>
<li><p>When you change a property in the inspector of the Renderer Feature.</p>
</li>
</ul>
</li>
<li><p><code>AddRenderPasses</code>: Unity calls this method every frame, once for each camera. This method lets you inject <code>ScriptableRenderPass</code> instances into the scriptable Renderer.</p>
</li>
</ul>
</li>
</ol>
<p>Now you have the custom <code>BlurRendererFeature</code> Renderer Feature with its main methods.</p>
<p>Below is the complete code for this step.</p>
<pre><code class="lang-C#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.Universal;

public class BlurRendererFeature : ScriptableRendererFeature
{
    public override void Create()
    {

    }

    public override void AddRenderPasses(ScriptableRenderer renderer,
        ref RenderingData renderingData)
    {

    }
}
</code></pre>
<h3 id="add-renderer-feature-to-asset">Add the Renderer Feature to the the Universal Renderer asset</h3>
<p>Add the Renderer Feature you created to the the Universal Renderer asset. For information on how to do this, refer to the page <a href="../urp-renderer-feature-how-to-add.html">How to add a Renderer Feature to a Renderer</a>.</p>
<h2 id="scriptable-render-pass">Create the scriptable Render Pass</h2>
<p>This section demonstrates how to create a scriptable Render Pass and enqueue its instance into the scriptable Renderer.</p>
<ol>
<li><p>Create a new C# script and name it <code>BlurRenderPass.cs</code>.</p>
</li>
<li><p>In the script, remove the code that Unity inserted in the <code>BlurRenderPass</code> class. Add the following <code>using</code> directive:</p>
<pre><code class="lang-C#">using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
</code></pre>
</li>
<li><p>Create the <code>BlurRenderPass</code> class that inherits from the <strong>ScriptableRenderPass</strong> class.</p>
<pre><code class="lang-C#">public class BlurRenderPass : ScriptableRenderPass
</code></pre>
</li>
<li><p>Add the <code>Execute</code> method to the class. Unity calls this method every frame, once for each camera. This method lets you implement the rendering logic of the scriptable Render Pass.</p>
<pre><code class="lang-C#">public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
{ }
</code></pre>
</li>
</ol>
<p>Below is the complete code for the BlurRenderPass.cs file from this section.</p>
<pre><code class="lang-C#">using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class BlurRenderPass : ScriptableRenderPass
{
    public override void Execute(ScriptableRenderContext context,
        ref RenderingData renderingData)
    {
        
    }
}
</code></pre>
<h2 id="implement-the-settings-for-the-custom-render-pass">Implement the settings for the custom render pass</h2>
<p>This section demonstrates how to implement the settings for the custom blur render pass.</p>
<ol>
<li><p>The Renderer Feature in this example uses the <a href="#example-shader">shader</a> that performs the blur horizontally in one pass, and vertically in another pass. To let users control the blur value for each pass, add the following <code>BlurSettings</code> class to the <code>BlurRendererFeature.cs</code> script.</p>
<pre><code class="lang-C#">[Serializable]
public class BlurSettings
{
    [Range(0,0.4f)] public float horizontalBlur;
    [Range(0,0.4f)] public float verticalBlur;
}
</code></pre>
</li>
<li><p>In the <code>BlurRendererFeature</code> class, declare the following fields:</p>
<pre><code class="lang-C#">[SerializeField] private BlurSettings settings;
[SerializeField] private Shader shader;
private Material material;
private BlurRenderPass blurRenderPass;
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> class, add the fields for the settings, the Material, and the constructor that uses those fields.</p>
<pre><code class="lang-C#">private BlurSettings defaultSettings;
private Material material;

public BlurRenderPass(Material material, BlurSettings defaultSettings)
{
    this.material = material;
    this.defaultSettings = defaultSettings;        
}
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> class, add the <code>RenderTextureDescriptor</code> field and initialize it in the constructor:</p>
<pre><code class="lang-C#">using UnityEngine;

private RenderTextureDescriptor blurTextureDescriptor;

public BlurRenderPass(Material material, BlurSettings defaultSettings)
{
    this.material = material;
    this.defaultSettings = defaultSettings;

    blurTextureDescriptor = new RenderTextureDescriptor(Screen.width,
        Screen.height, RenderTextureFormat.Default, 0);
}
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> class, declare the <code>RTHandle</code> field to store the reference to the temporary blur texture.</p>
<pre><code class="lang-C#">private RTHandle blurTextureHandle;
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> class, implement the <code>Configure</code> method. Unity calls this method before executing the render pass.</p>
<pre><code class="lang-C#">public override void Configure(CommandBuffer cmd,
    RenderTextureDescriptor cameraTextureDescriptor)
{
    //Set the blur texture size to be the same as the camera target size.
    blurTextureDescriptor.width = cameraTextureDescriptor.width;
    blurTextureDescriptor.height = cameraTextureDescriptor.height;

    //Check if the descriptor has changed, and reallocate the RTHandle if necessary.
    RenderingUtils.ReAllocateIfNeeded(ref blurTextureHandle, blurTextureDescriptor);
}
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> class, implement the <code>UpdateBlurSettings</code> method that updates the shader values.</p>
<p>Use the <code>Blit</code> method to apply the two passes from the custom shader to the camera output.</p>
<pre><code class="lang-C#">private static readonly int horizontalBlurId =
    Shader.PropertyToID(&quot;_HorizontalBlur&quot;);
private static readonly int verticalBlurId =
    Shader.PropertyToID(&quot;_VerticalBlur&quot;);

...

private void UpdateBlurSettings()
{
    if (material == null) return;

    material.SetFloat(horizontalBlurId, defaultSettings.horizontalBlur);
    material.SetFloat(verticalBlurId, defaultSettings.verticalBlur);
}
</code></pre>
</li>
<li><p>Call the <code>UpdateBlurSettings</code> method in the <code>Execute</code> method.</p>
<pre><code class="lang-C#">public override void Execute(ScriptableRenderContext context,
    ref RenderingData renderingData)
{
    //Get a CommandBuffer from pool.
    CommandBuffer cmd = CommandBufferPool.Get();

    RTHandle cameraTargetHandle =
        renderingData.cameraData.renderer.cameraColorTargetHandle;

    UpdateBlurSettings();

    // Blit from the camera target to the temporary render texture,
    // using the first shader pass.
    Blit(cmd, cameraTargetHandle, blurTextureHandle, material, 0);
    // Blit from the temporary render texture to the camera target,
    // using the second shader pass.
    Blit(cmd, blurTextureHandle, cameraTargetHandle, material, 1);

    //Execute the command buffer and release it back to the pool.
    context.ExecuteCommandBuffer(cmd);
    CommandBufferPool.Release(cmd);
}
</code></pre>
</li>
<li><p>Implement the <code>Dispose</code> method that destroys the Material and the temporary render texture after the render pass execution.</p>
<pre><code class="lang-C#">public void Dispose()
{
    #if UNITY_EDITOR
            if (EditorApplication.isPlaying)
            {
                Object.Destroy(material);
            }
            else
            {
                Object.DestroyImmediate(material);
            }
    #else
            Object.Destroy(material);
    #endif

    if (blurTextureHandle != null) blurTextureHandle.Release();
}
</code></pre>
</li>
</ol>
<p>The complete code for this part is in section <a href="#code-render-pass">Custom render pass code</a>.</p>
<h2 id="enqueue-the-render-pass-in-the-custom-renderer-feature">Enqueue the render pass in the custom renderer feature</h2>
<p>In this section, you instantiate the render pass in the <code>Create</code> method of the <code>BlurRendererFeature</code> class, and enqueue it in the <code>AddRenderPasses</code> method.</p>
<ol>
<li><p>In the <code>Create</code> method of the <code>BlurRendererFeature</code> class, instantiate the <code>BlurRenderPass</code> class.</p>
<p>In the method, use the <code>renderPassEvent</code> field to specify when to execute the render pass.</p>
<pre><code class="lang-C#">public override void Create()
{
    if (shader == null)
    {
        return;
    }
    material = new Material(shader);
    blurRenderPass = new BlurRenderPass(material, settings);

    renderPassEvent = RenderPassEvent.AfterRenderingSkybox;
}
</code></pre>
</li>
<li><p>In the <code>AddRenderPasses</code> method of the <code>BlurRendererFeature</code> class, enqueue the render pass with the <code>EnqueuePass</code> method.</p>
<pre><code class="lang-C#">public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
{
    if (renderingData.cameraData.cameraType == CameraType.Game)
    {
        renderer.EnqueuePass(blurRenderPass);
    }
}
</code></pre>
</li>
<li><p>Implement the <code>Dispose</code> method that destroys the material instance that the Renderer Feature creates. The method also calls the <code>Dispose</code> method from the render pass class.</p>
<pre><code class="lang-C#">protected override void Dispose(bool disposing)
{
    blurRenderPass.Dispose();
    #if UNITY_EDITOR
        if (EditorApplication.isPlaying)
        {
            Destroy(material);
        }
        else
        {
            DestroyImmediate(material);
        }
    #else
            Destroy(material);
    #endif
}
</code></pre>
</li>
</ol>
<p>For the complete Renderer Feature code, refer to section <a href="#code-renderer-feature">Custom Renderer Feature code</a>.</p>
<p>The Scriptable Renderer Feature is now complete. The following image shows the effect of the feature in the Game view and the example settings.</p>
<p><img src="../Images/customizing-urp/custom-renderer-feature/final-effect.png" alt="The effect of the Scriptable Renderer Feature in the Game view"><br><em>The effect of the Scriptable Renderer Feature in the Game view.</em></p>
<h2 id="volume-component">Implement the volume component</h2>
<p>This section shows how to implement a volume component that lets you control the input values for the custom renderer feature.</p>
<ol>
<li><p>Create a new C# script and name it <code>CustomVolumeComponent.cs</code>.</p>
</li>
<li><p>Inherit the <code>CustomVolumeComponent</code> class from the <code>VolumeComponent</code> class, add the <code>[Serializable]</code> attribute to the class. Add the <code>using UnityEngine.Rendering;</code> directive.</p>
<pre><code class="lang-C#">using System;
using UnityEngine.Rendering;

[Serializable]
public class CustomVolumeComponent : VolumeComponent
{

}
</code></pre>
</li>
<li><p>Add the <code>BoolParameter</code> field to the <code>CustomVolumeComponent</code> class. This field lets you enable or disable the custom renderer feature.</p>
<pre><code class="lang-C#">public class BlurVolumeComponent : VolumeComponent
{
    public BoolParameter isActive = new BoolParameter(true);
}
</code></pre>
</li>
<li><p>Add the fields to control the blur settings defined in the custom renderer feature.</p>
<pre><code class="lang-C#">[Serializable]
public class CustomVolumeComponent : VolumeComponent
{
    public BoolParameter isActive = new BoolParameter(true);
    public ClampedFloatParameter horizontalBlur =
        new ClampedFloatParameter(0.05f, 0, 0.5f);
    public ClampedFloatParameter verticalBlur =
        new ClampedFloatParameter(0.05f, 0, 0.5f);
}
</code></pre>
</li>
<li><p>In the <code>BlurRenderPass</code> script, change the <code>UpdateBlurSettings</code> method so that it uses the settings defined in a Volume or the default settings if no Volume is set.</p>
<pre><code class="lang-C#">private void UpdateBlurSettings()
{
    if (material == null) return;

    // Use the Volume settings or the default settings if no Volume is set.
    var volumeComponent =
        VolumeManager.instance.stack.GetComponent&lt;CustomVolumeComponent&gt;();
    float horizontalBlur = volumeComponent.horizontalBlur.overrideState ?
        volumeComponent.horizontalBlur.value : defaultSettings.horizontalBlur;
    float verticalBlur = volumeComponent.verticalBlur.overrideState ?
        volumeComponent.verticalBlur.value : defaultSettings.verticalBlur;
    material.SetFloat(horizontalBlurId, horizontalBlur);
    material.SetFloat(verticalBlurId, verticalBlur);
}
</code></pre>
</li>
<li><p>In the Unity scene, create a <a href="../Volumes.html">local Box Volume</a>. If a <a href="../VolumeProfile.html">Volume Profile</a> is missing, create a new one by clicking <strong>New</strong> next to the <strong>Profile</strong> property. Add the <code>Custom Volume Component</code> <a href="../VolumeOverrides.html">override</a> to the Volume.</p>
<p><img src="../Images/customizing-urp/custom-renderer-feature/local-volume.png" alt="Box Volume properties"></p>
</li>
<li><p>Enable the settings in the <code>Custom Volume Component</code> override and set the values for this Volume. Move the Volume so that the camera is inside it. The settings from the Volume override the default settings from the custom renderer feature.</p>
</li>
</ol>
<h2 id="all-complete-code-for-the-scripts-in-this-example">All complete code for the scripts in this example</h2>
<p>This section contains the complete code for all the scripts in this example.</p>
<h3 id="code-renderer-feature">Custom Renderer Feature code</h3>
<p>Below is the complete code for the custom Renderer Feature script.</p>
<pre><code class="lang-C#">using System;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering.Universal;

public class BlurRendererFeature : ScriptableRendererFeature
{
    [SerializeField] private BlurSettings settings;
    [SerializeField] private Shader shader;
    private Material material;
    private BlurRenderPass blurRenderPass;

    public override void Create()
    {
        if (shader == null)
        {
            return;
        }
        material = new Material(shader);
        blurRenderPass = new BlurRenderPass(material, settings);
        
        blurRenderPass.renderPassEvent = RenderPassEvent.AfterRenderingSkybox;
    }

    public override void AddRenderPasses(ScriptableRenderer renderer,
        ref RenderingData renderingData)
    {
        if (renderingData.cameraData.cameraType == CameraType.Game)
        {
            renderer.EnqueuePass(blurRenderPass);
        }
    }

    protected override void Dispose(bool disposing)
    {
        blurRenderPass.Dispose();
        #if UNITY_EDITOR
            if (EditorApplication.isPlaying)
            {
                Destroy(material);
            }
            else
            {
                DestroyImmediate(material);
            }
        #else
                Destroy(material);
        #endif
    }
}

[Serializable]
public class BlurSettings
{
    [Range(0, 0.4f)] public float horizontalBlur;
    [Range(0, 0.4f)] public float verticalBlur;
}
</code></pre>
<h3 id="code-render-pass">Custom render pass code</h3>
<p>Below is the complete code for the custom Render Pass script.</p>
<pre><code class="lang-C#">using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class BlurRenderPass : ScriptableRenderPass
{
    private static readonly int horizontalBlurId =
        Shader.PropertyToID(&quot;_HorizontalBlur&quot;);
    private static readonly int verticalBlurId =
        Shader.PropertyToID(&quot;_VerticalBlur&quot;);

    private BlurSettings defaultSettings;
    private Material material;

    private RenderTextureDescriptor blurTextureDescriptor;
    private RTHandle blurTextureHandle;

    public BlurRenderPass(Material material, BlurSettings defaultSettings)
    {
        this.material = material;
        this.defaultSettings = defaultSettings;

        blurTextureDescriptor = new RenderTextureDescriptor(Screen.width,
            Screen.height, RenderTextureFormat.Default, 0);
    }

    public override void Configure(CommandBuffer cmd,
        RenderTextureDescriptor cameraTextureDescriptor)
    {
        // Set the blur texture size to be the same as the camera target size.
        blurTextureDescriptor.width = cameraTextureDescriptor.width;
        blurTextureDescriptor.height = cameraTextureDescriptor.height;

        // Check if the descriptor has changed, and reallocate the RTHandle if necessary
        RenderingUtils.ReAllocateIfNeeded(ref blurTextureHandle, blurTextureDescriptor);
    }

    private void UpdateBlurSettings()
    {
        if (material == null) return;

        // Use the Volume settings or the default settings if no Volume is set.
        var volumeComponent =
            VolumeManager.instance.stack.GetComponent&lt;CustomVolumeComponent&gt;();
        float horizontalBlur = volumeComponent.horizontalBlur.overrideState ?
            volumeComponent.horizontalBlur.value : defaultSettings.horizontalBlur;
        float verticalBlur = volumeComponent.verticalBlur.overrideState ?
            volumeComponent.verticalBlur.value : defaultSettings.verticalBlur;
        material.SetFloat(horizontalBlurId, horizontalBlur);
        material.SetFloat(verticalBlurId, verticalBlur);
    }

    public override void Execute(ScriptableRenderContext context,
        ref RenderingData renderingData)
    {
        //Get a CommandBuffer from pool.
        CommandBuffer cmd = CommandBufferPool.Get();

        RTHandle cameraTargetHandle =
            renderingData.cameraData.renderer.cameraColorTargetHandle;

        UpdateBlurSettings();

        // Blit from the camera target to the temporary render texture,
        // using the first shader pass.
        Blit(cmd, cameraTargetHandle, blurTextureHandle, material, 0);
        // Blit from the temporary render texture to the camera target,
        // using the second shader pass.
        Blit(cmd, blurTextureHandle, cameraTargetHandle, material, 1);

        //Execute the command buffer and release it back to the pool.
        context.ExecuteCommandBuffer(cmd);
        CommandBufferPool.Release(cmd);
    }

    public void Dispose()
    {
    #if UNITY_EDITOR
        if (EditorApplication.isPlaying)
        {
            Object.Destroy(material);
        }
        else
        {
            Object.DestroyImmediate(material);
        }
    #else
                Object.Destroy(material);
    #endif

        if (blurTextureHandle != null) blurTextureHandle.Release();
    }
}
</code></pre>
<h3 id="code-volume-component">Volume Component code</h3>
<p>Below is the complete code for the Volume Component script.</p>
<pre><code class="lang-C#">using System;
using UnityEngine.Rendering;

[Serializable]
public class CustomVolumeComponent : VolumeComponent
{
    public BoolParameter isActive = new BoolParameter(true);
    public ClampedFloatParameter horizontalBlur =
        new ClampedFloatParameter(0.05f, 0, 0.5f);
    public ClampedFloatParameter verticalBlur =
        new ClampedFloatParameter(0.05f, 0, 0.5f);
}
</code></pre>
<h2 id="example-shader">The custom shader for the blur effect</h2>
<p>This section contains the code for the custom shader that implements the blur effect.</p>
<pre><code class="lang-c++">Shader &quot;CustomEffects/Blur&quot;
{
    HLSLINCLUDE
    
        #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
        // The Blit.hlsl file provides the vertex shader (Vert),
        // the input structure (Attributes), and the output structure (Varyings)
        #include &quot;Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl&quot;

        float _VerticalBlur;
        float _HorizontalBlur;
    
        float4 _BlitTexture_TexelSize;
    
        float4 BlurVertical (Varyings input) : SV_Target
        {
            const float BLUR_SAMPLES = 64;
            const float BLUR_SAMPLES_RANGE = BLUR_SAMPLES / 2;
            
            float3 color = 0;
            float blurPixels = _VerticalBlur * _ScreenParams.y;
            
            for(float i = -BLUR_SAMPLES_RANGE; i &lt;= BLUR_SAMPLES_RANGE; i++)
            {
                float2 sampleOffset =
                    float2 (0, (blurPixels / _BlitTexture_TexelSize.w) *
                        (i / BLUR_SAMPLES_RANGE));
                color +=
                    SAMPLE_TEXTURE2D(_BlitTexture, sampler_LinearClamp,
                        input.texcoord + sampleOffset).rgb;
            }
            
            return float4(color.rgb / (BLUR_SAMPLES + 1), 1);
        }

        float4 BlurHorizontal (Varyings input) : SV_Target
        {
            const float BLUR_SAMPLES = 64;
            const float BLUR_SAMPLES_RANGE = BLUR_SAMPLES / 2;
            
            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);
            float3 color = 0;
            float blurPixels = _HorizontalBlur * _ScreenParams.x;
            for(float i = -BLUR_SAMPLES_RANGE; i &lt;= BLUR_SAMPLES_RANGE; i++)
            {
                float2 sampleOffset =
                    float2 ((blurPixels / _BlitTexture_TexelSize.z) *
                        (i / BLUR_SAMPLES_RANGE), 0);
                color +=
                    SAMPLE_TEXTURE2D(_BlitTexture, sampler_LinearClamp,
                        input.texcoord + sampleOffset).rgb;
            }
            return float4(color / (BLUR_SAMPLES + 1), 1);
        }
    
    ENDHLSL
    
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot;}
        LOD 100
        ZWrite Off Cull Off
        Pass
        {
            Name &quot;BlurPassVertical&quot;

            HLSLPROGRAM
            
            #pragma vertex Vert
            #pragma fragment BlurVertical
            
            ENDHLSL
        }
        
        Pass
        {
            Name &quot;BlurPassHorizontal&quot;

            HLSLPROGRAM
            
            #pragma vertex Vert
            #pragma fragment BlurHorizontal
            
            ENDHLSL
        }
    }
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/0xVector/mmo-rpg-unity/blob/master/Library/PackageCache/com.unity.render-pipelines.universal@14.0.11/Documentation~/containers/create-custom-renderer-feature-1.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
